# R1. Ревью бизнес-логики — Dave Cheney

> **Ветка:** devel -> master
> **Коммиты:** Add backend API, Add frontend, Add vt

## Общее впечатление

Это крупный MR, который добавляет полноценную систему code review: бэкенд (REST + JSON-RPC), фронтенд (Vue 3 SPA), VT-админку, Slack-нотификации, Docker-деплой и CI-интеграцию. Архитектурно приложение разделено на слои: `db` (data access), `reviewer` (domain/business logic), `rpc` (JSON-RPC API), `rest` (REST API), `slack` (notifications), `vt` (admin CRUD), `app` (composition root). Подход верный и характерный для Go-приложений.

## Замечания по бизнес-логике

### 1. [high] Отсутствует валидация обязательных полей ReviewDraft

**Файл:** `pkg/rest/model.go:46-61`

`ReviewDraft.Validate()` проверяет только `reviewType`, `fileType` и `severity`, но не проверяет обязательные поля: `Title`, `Author`, `CommitHash`, `SourceBranch`, `TargetBranch`. Можно создать ревью с пустым title и author, что приведёт к бессмысленным записям в БД и некорректным Slack-уведомлениям.

```go
func (rd ReviewDraft) Validate() error {
    // Нет проверки: rd.Review.Title, rd.Review.Author, rd.Review.CommitHash и т.д.
    for _, f := range rd.Files {
        if !reviewer.IsValidReviewType(f.ReviewType) {
            return fmt.Errorf("invalid reviewType: %s", f.ReviewType)
        }
    }
    // ...
}
```

**Рекомендация:** добавить проверку обязательных строковых полей в `Validate()`.

### 2. [high] Нет проверки соответствия issues и files в ReviewDraft

**Файл:** `pkg/rest/model.go:85-108`

В `ToModel()` issues группируются по `FileType` и назначаются review files. Если issue указывает `fileType`, которого нет в `files`, она молча теряется. Нет проверки в `Validate()`, что каждый `issue.FileType` соответствует одному из `files[].ReviewType`. В итоге часть issues может быть потеряна при загрузке ревью, и это никак не сигнализируется.

```go
issuesByType := make(map[string]reviewer.Issues, len(rd.Files))
for _, iss := range rd.Issues {
    issuesByType[iss.FileType] = append(issuesByType[iss.FileType], ...)
}
// Если FileType не совпадает ни с одним ReviewType из Files — issue теряется
```

**Рекомендация:** в `Validate()` проверить, что `issue.FileType` присутствует среди `files[].ReviewType`.

### 3. [medium] ReviewManager.runInLock создаёт TxManager с DB вместо TX

**Файл:** `pkg/reviewer/manager.go:25-35`

В `runInLock` создаётся `txRM` с `TxManager: db.NewTxManager(rm.DB())`, но `rm.DB()` возвращает указатель на базу, а не транзакцию. Код затем вызывает `txRM.SetTx(tx)`. Это работает, но `NewTxManager` получает `*DB`, а `repo` уже имеет `WithTransaction(tx)`. Потенциальная путаница: если кто-то вызовет `txRM.Conn()` до `SetTx` — получит не-транзакционное соединение. Код сейчас корректен, но хрупок.

### 4. [medium] UploadReviewFile не ограничивает размер Body

**Файл:** `pkg/rest/rest.go:139`

`UploadReviewFile` читает `io.ReadAll(c.Request().Body)` без ограничения размера. Хотя middleware `BodyLimit("2M")` стоит глобально, оно применяется при обработке запроса echo. Но для формы `POST` без content-length middleware может не сработать правильно. Рекомендуется явно ограничить чтение через `io.LimitReader`.

```go
content, err := io.ReadAll(c.Request().Body)
```

### 5. [medium] Нет валидации длин строковых полей в ReviewDraft

**Файл:** `pkg/rest/model.go:11-43`

Поля `Title`, `Description`, `Content`, `File` принимают строки произвольной длины. Если клод сгенерирует гигантский `content` для issue, это может привести к проблемам в БД (если есть ограничения на колонки) или к неоправданно большим записям.

### 6. [low] calcIssueStats молча игнорирует неизвестные severity

**Файл:** `pkg/reviewer/model.go:150-166`

Если в issues попадётся severity, отличная от четырёх известных, она будет проигнорирована в подсчёте, но `Total` не будет включать эту issue. При этом `Validate()` в REST уже проверяет severity, поэтому на практике ситуация маловероятна. Однако в тестах (`TestCalcIssueStats`) этот случай есть и `Total=1` при 3 issues — что может сбить с толку.

### 7. [low] ProjectsStats использует raw SQL вместо ORM

**Файл:** `pkg/reviewer/manager.go:128-150`

Raw SQL запрос с `DISTINCT ON` и `count(*) OVER (PARTITION BY ...)` не использует ORM-механизмы, присутствующие в остальном проекте. Это не ошибка, но усложняет поддержку при изменении схемы (переименование колонок и т.д.). Стоит добавить комментарий, объясняющий выбор raw SQL.

## Потенциальные проблемы бизнес-логики при масштабировании

1. **Отсутствие пагинации в `ProjectsStats`** — запрос возвращает статистику по всем проектам одним SQL. При росте количества проектов и ревью может стать медленным.
2. **Жёсткий лимит issues = 500** (`pkg/rpc/review.go:143`) — при большом количестве issues на ревью часть будет обрезана без уведомления клиента.
3. **Slack-уведомление в горутине без отслеживания** (`pkg/rest/rest.go:112`) — ошибка отправки в Slack логируется, но не влияет на ответ клиенту. Это правильно, но при массовых ошибках может быть проблема с горутинами.

## Вывод

Бизнес-логика в целом корректна и хорошо структурирована. Основные проблемы — недостаточная валидация входных данных в REST-слое: отсутствие проверки обязательных полей и потенциальная потеря issues при несовпадении `fileType` и `reviewType`. Это может привести к сохранению некорректных данных.
