# R3. Ревью безопасности — Filippo Valsorda

> **Ветка:** devel -> master
> **Коммиты:** Add backend API, Add frontend, Add vt

## Общее впечатление

Приложение представляет собой внутренний инструмент для code review. Поверхность атаки включает: REST API для загрузки ревью (публичный), JSON-RPC API для фронтенда, VT-админку с аутентификацией, Slack webhook-интеграцию. Рассмотрю каждый вектор.

## Замечания по безопасности

### 1. [high] REST API полностью без аутентификации

**Файл:** `pkg/app/handlers.go:71-74`

REST-эндпоинты (`/v1/prompt/`, `/v1/upload/`) не имеют никакой аутентификации:

```go
a.echo.GET("/v1/prompt/:projectKey/", h.GetPrompt, lg)
a.echo.GET("/v1/upload/upload.js", h.GetUploadScript, lg)
a.echo.POST("/v1/upload/:projectKey/", h.CreateReview, lg)
a.echo.POST("/v1/upload/:projectKey/:reviewId/:reviewType/", h.UploadReviewFile, lg)
```

Единственная «защита» — знание UUID `projectKey`. UUID v4 обеспечивает 122 бита энтропии, что делает brute-force нереалистичным. Однако:
- UUID может утечь через логи, Slack-сообщения, CI pipeline
- `GetPrompt` возвращает prompt, содержащий **auth token task tracker'а** (подстановка `{{TOKEN}}` на реальный токен происходит в `createPrompt`)
- Любой, знающий `projectKey`, может загрузить произвольное ревью

README рекомендует закрывать `/v1/prompt/` и `/v1/upload/` через nginx, но это не реализовано на уровне приложения.

**Рекомендация:** добавить API-ключ или Bearer-токен для REST-эндпоинтов. Как минимум, задокументировать в конфиге обязательность reverse proxy для production.

### 2. [high] Auth token task tracker'а передаётся через prompt в открытом виде

**Файл:** `pkg/reviewer/project.go:93`

```go
data.FetchPrompt = strings.ReplaceAll(pr.TaskTracker.FetchPrompt, "{{TOKEN}}", pr.TaskTracker.AuthToken)
```

`GetPrompt` API возвращает собранный prompt с подставленным auth token. Этот endpoint доступен без аутентификации (только UUID). Auth token YouTrack'а (или другого трекера) передаётся в открытом виде. Если кто-то получит доступ к `projectKey`, он получит и auth token.

**Рекомендация:** рассмотреть альтернативный подход — передавать token как переменную окружения в CI, а не через API.

### 3. [high] Нет аутентификации на JSON-RPC API (review namespace)

**Файл:** `pkg/rpc/server.go:29-56`

JSON-RPC эндпоинт `/v1/rpc/` не имеет аутентификации. Методы `review.Feedback` и `review.SetComment` позволяют менять данные. Любой пользователь может:
- Пометить любой issue как false positive
- Оставить комментарий к любому issue
- Просматривать все ревью всех проектов

Для внутреннего инструмента это может быть приемлемо, но `Feedback` и `SetComment` — это запись, которая должна быть защищена.

**Рекомендация:** добавить хотя бы базовую аутентификацию для write-операций.

### 4. [medium] CORS настроен с AllowOrigins: ["*"]

**Файл:** `pkg/app/handlers.go:35-38`

```go
middleware.CORSWithConfig(middleware.CORSConfig{
    AllowOrigins: []string{"*"},
    AllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},
    AllowHeaders: []string{"Authorization", "Authorization2", ...},
})
```

Wildcard CORS разрешает запросы с любого origin. В сочетании с отсутствием аутентификации на RPC-эндпоинтах это означает, что любой сайт может делать запросы к API от имени пользователя. Для внутреннего инструмента риск ниже, но при выходе в публичную сеть — серьёзная проблема.

**Рекомендация:** ограничить `AllowOrigins` конкретным доменом или использовать `BaseURL` из конфига.

### 5. [medium] Slack webhook URL хранится без шифрования

**Файл:** `pkg/db/model.go:364-372`

`WebhookURL` хранится в БД как `string` без шифрования. Slack incoming webhook URL — это секрет; знание URL позволяет отправлять сообщения в канал. При утечке БД или SQL injection (если бы он был) webhook URL компрометируется.

**Рекомендация:** для production рассмотреть шифрование секретов в БД или хранение в vault.

### 6. [medium] Debug-хендлеры pprof доступны в production

**Файл:** `pkg/app/handlers.go:78-82`

```go
func (a *App) registerDebugHandlers() {
    dbg := a.echo.Group("/debug")
    dbg.Any("/debug/pprof/*", appkit.PprofHandler)
```

pprof-эндпоинты регистрируются безусловно, без проверки `IsDevel`. Это позволяет в production получить профили CPU, памяти, горутин — ценную информацию для атакующего. Также `pprof` может содержать чувствительные данные (stack traces со значениями переменных).

**Рекомендация:** регистрировать `/debug/pprof/` только при `IsDevel == true`.

### 7. [low] Docker-compose использует стандартный пароль postgres

**Файл:** `docker-compose.yml`

```yaml
environment:
  POSTGRES_PASSWORD: postgres
```

Стандартный пароль `postgres` в docker-compose. Для локальной разработки приемлемо, но если файл используется как шаблон для деплоя — риск.

## Принятые риски (не дублируются)

- Auth token в тестовом файле `pkg/reviewer/init_test.go` — принят
- XSS через `v-html` в `MarkdownContent.vue` — принят

## Вывод

Основные проблемы безопасности связаны с отсутствием аутентификации на REST и JSON-RPC API. Для внутреннего инструмента за reverse proxy это приемлемо, но auth token task tracker'а, отдаваемый через публичный endpoint, представляет реальный риск. Debug-эндпоинты pprof должны быть ограничены development-режимом.
