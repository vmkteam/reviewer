// Code generated by mfd-generator v0.6.1; DO NOT EDIT.

//nolint:all
//lint:file-ignore U1000 ignore unused code, it's generated
package db

import (
	"time"

	"github.com/go-pg/pg/v10"
	"github.com/go-pg/pg/v10/orm"
)

const condition = "?.? = ?"

// base filters
type applier func(query *orm.Query) (*orm.Query, error)

type search struct {
	appliers []applier
}

func (s *search) apply(query *orm.Query) {
	for _, applier := range s.appliers {
		query.Apply(applier)
	}
}

func (s *search) where(query *orm.Query, table, field string, value interface{}) {
	query.Where(condition, pg.Ident(table), pg.Ident(field), value)
}

func (s *search) WithApply(a applier) {
	if s.appliers == nil {
		s.appliers = []applier{}
	}
	s.appliers = append(s.appliers, a)
}

func (s *search) With(condition string, params ...interface{}) {
	s.WithApply(func(query *orm.Query) (*orm.Query, error) {
		return query.Where(condition, params...), nil
	})
}

// Searcher is interface for every generated filter
type Searcher interface {
	Apply(query *orm.Query) *orm.Query
	Q() applier

	With(condition string, params ...interface{})
	WithApply(a applier)
}

type UserSearch struct {
	search

	ID                 *int
	CreatedAt          *time.Time
	Login              *string
	Password           *string
	AuthKey            *string
	LastActivityAt     *time.Time
	StatusID           *int
	IDs                []int
	NotID              *int
	LoginILike         *string
	PasswordILike      *string
	AuthKeyILike       *string
	LastActivityAtFrom *time.Time
	LastActivityAtTo   *time.Time
}

func (us *UserSearch) Apply(query *orm.Query) *orm.Query {
	if us == nil {
		return query
	}
	if us.ID != nil {
		us.where(query, Tables.User.Alias, Columns.User.ID, us.ID)
	}
	if us.CreatedAt != nil {
		us.where(query, Tables.User.Alias, Columns.User.CreatedAt, us.CreatedAt)
	}
	if us.Login != nil {
		us.where(query, Tables.User.Alias, Columns.User.Login, us.Login)
	}
	if us.Password != nil {
		us.where(query, Tables.User.Alias, Columns.User.Password, us.Password)
	}
	if us.AuthKey != nil {
		us.where(query, Tables.User.Alias, Columns.User.AuthKey, us.AuthKey)
	}
	if us.LastActivityAt != nil {
		us.where(query, Tables.User.Alias, Columns.User.LastActivityAt, us.LastActivityAt)
	}
	if us.StatusID != nil {
		us.where(query, Tables.User.Alias, Columns.User.StatusID, us.StatusID)
	}
	if len(us.IDs) > 0 {
		Filter{Columns.User.ID, us.IDs, SearchTypeArray, false}.Apply(query)
	}
	if us.NotID != nil {
		Filter{Columns.User.ID, *us.NotID, SearchTypeEquals, true}.Apply(query)
	}
	if us.LoginILike != nil {
		Filter{Columns.User.Login, *us.LoginILike, SearchTypeILike, false}.Apply(query)
	}
	if us.PasswordILike != nil {
		Filter{Columns.User.Password, *us.PasswordILike, SearchTypeILike, false}.Apply(query)
	}
	if us.AuthKeyILike != nil {
		Filter{Columns.User.AuthKey, *us.AuthKeyILike, SearchTypeILike, false}.Apply(query)
	}
	if us.LastActivityAtFrom != nil {
		Filter{Columns.User.LastActivityAt, *us.LastActivityAtFrom, SearchTypeGE, false}.Apply(query)
	}
	if us.LastActivityAtTo != nil {
		Filter{Columns.User.LastActivityAt, *us.LastActivityAtTo, SearchTypeLE, false}.Apply(query)
	}

	us.apply(query)

	return query
}

func (us *UserSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if us == nil {
			return query, nil
		}
		return us.Apply(query), nil
	}
}

type IssueSearch struct {
	search

	ID                   *int
	ReviewFileID         *int
	IssueType            *string
	ReviewID             *int
	Title                *string
	Severity             *string
	Description          *string
	Content              *string
	File                 *string
	Lines                *string
	Comment              *string
	IsFalsePositive      *bool
	ProcessedAt          *time.Time
	CreatedAt            *time.Time
	UserID               *int
	StatusID             *int
	LocalID              *string
	IDs                  []int
	IssueTypeILike       *string
	TitleILike           *string
	SeverityILike        *string
	DescriptionILike     *string
	ContentILike         *string
	FileILike            *string
	LinesILike           *string
	CommentILike         *string
	ReviewFileReviewType *string
	ReviewProjectID      *int
}

func (is *IssueSearch) Apply(query *orm.Query) *orm.Query {
	if is == nil {
		return query
	}
	if is.ID != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.ID, is.ID)
	}
	if is.ReviewFileID != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.ReviewFileID, is.ReviewFileID)
	}
	if is.IssueType != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.IssueType, is.IssueType)
	}
	if is.ReviewID != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.ReviewID, is.ReviewID)
	}
	if is.Title != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.Title, is.Title)
	}
	if is.Severity != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.Severity, is.Severity)
	}
	if is.Description != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.Description, is.Description)
	}
	if is.Content != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.Content, is.Content)
	}
	if is.File != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.File, is.File)
	}
	if is.Lines != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.Lines, is.Lines)
	}
	if is.Comment != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.Comment, is.Comment)
	}
	if is.IsFalsePositive != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.IsFalsePositive, is.IsFalsePositive)
	}
	if is.ProcessedAt != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.ProcessedAt, is.ProcessedAt)
	}
	if is.CreatedAt != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.CreatedAt, is.CreatedAt)
	}
	if is.UserID != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.UserID, is.UserID)
	}
	if is.StatusID != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.StatusID, is.StatusID)
	}
	if is.LocalID != nil {
		is.where(query, Tables.Issue.Alias, Columns.Issue.LocalID, is.LocalID)
	}
	if len(is.IDs) > 0 {
		Filter{Columns.Issue.ID, is.IDs, SearchTypeArray, false}.Apply(query)
	}
	if is.IssueTypeILike != nil {
		Filter{Columns.Issue.IssueType, *is.IssueTypeILike, SearchTypeILike, false}.Apply(query)
	}
	if is.TitleILike != nil {
		Filter{Columns.Issue.Title, *is.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if is.SeverityILike != nil {
		Filter{Columns.Issue.Severity, *is.SeverityILike, SearchTypeILike, false}.Apply(query)
	}
	if is.DescriptionILike != nil {
		Filter{Columns.Issue.Description, *is.DescriptionILike, SearchTypeILike, false}.Apply(query)
	}
	if is.ContentILike != nil {
		Filter{Columns.Issue.Content, *is.ContentILike, SearchTypeILike, false}.Apply(query)
	}
	if is.FileILike != nil {
		Filter{Columns.Issue.File, *is.FileILike, SearchTypeILike, false}.Apply(query)
	}
	if is.LinesILike != nil {
		Filter{Columns.Issue.Lines, *is.LinesILike, SearchTypeILike, false}.Apply(query)
	}
	if is.CommentILike != nil {
		Filter{Columns.Issue.Comment, *is.CommentILike, SearchTypeILike, false}.Apply(query)
	}
	if is.ReviewFileReviewType != nil {
		Filter{"review_file.reviewType", *is.ReviewFileReviewType, SearchTypeEquals, false}.Apply(query)
	}
	if is.ReviewProjectID != nil {
		Filter{"review.projectId", *is.ReviewProjectID, SearchTypeEquals, false}.Apply(query)
	}

	is.apply(query)

	return query
}

func (is *IssueSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if is == nil {
			return query, nil
		}
		return is.Apply(query), nil
	}
}

type ReviewFileSearch struct {
	search

	ID                *int
	ReviewID          *int
	ReviewType        *string
	Content           *string
	TrafficLight      *string
	CreatedAt         *time.Time
	Summary           *string
	IsAccepted        *bool
	StatusID          *int
	IDs               []int
	ReviewTypeILike   *string
	ContentILike      *string
	TrafficLightILike *string
	SummaryILike      *string
	ReviewIDs         []int
}

func (rfs *ReviewFileSearch) Apply(query *orm.Query) *orm.Query {
	if rfs == nil {
		return query
	}
	if rfs.ID != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.ID, rfs.ID)
	}
	if rfs.ReviewID != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.ReviewID, rfs.ReviewID)
	}
	if rfs.ReviewType != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.ReviewType, rfs.ReviewType)
	}
	if rfs.Content != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.Content, rfs.Content)
	}
	if rfs.TrafficLight != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.TrafficLight, rfs.TrafficLight)
	}
	if rfs.CreatedAt != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.CreatedAt, rfs.CreatedAt)
	}
	if rfs.Summary != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.Summary, rfs.Summary)
	}
	if rfs.IsAccepted != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.IsAccepted, rfs.IsAccepted)
	}
	if rfs.StatusID != nil {
		rfs.where(query, Tables.ReviewFile.Alias, Columns.ReviewFile.StatusID, rfs.StatusID)
	}
	if len(rfs.IDs) > 0 {
		Filter{Columns.ReviewFile.ID, rfs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if rfs.ReviewTypeILike != nil {
		Filter{Columns.ReviewFile.ReviewType, *rfs.ReviewTypeILike, SearchTypeILike, false}.Apply(query)
	}
	if rfs.ContentILike != nil {
		Filter{Columns.ReviewFile.Content, *rfs.ContentILike, SearchTypeILike, false}.Apply(query)
	}
	if rfs.TrafficLightILike != nil {
		Filter{Columns.ReviewFile.TrafficLight, *rfs.TrafficLightILike, SearchTypeILike, false}.Apply(query)
	}
	if rfs.SummaryILike != nil {
		Filter{Columns.ReviewFile.Summary, *rfs.SummaryILike, SearchTypeILike, false}.Apply(query)
	}
	if len(rfs.ReviewIDs) > 0 {
		Filter{Columns.ReviewFile.ReviewID, rfs.ReviewIDs, SearchTypeArray, false}.Apply(query)
	}

	rfs.apply(query)

	return query
}

func (rfs *ReviewFileSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if rfs == nil {
			return query, nil
		}
		return rfs.Apply(query), nil
	}
}

type ReviewSearch struct {
	search

	ID           *int
	ProjectID    *int
	Title        *string
	Description  *string
	ExternalID   *string
	TrafficLight *string
	CommitHash   *string
	SourceBranch *string
	TargetBranch *string
	Author       *string
	CreatedAt    *time.Time
	DurationMS   *int
	StatusID     *int
	PromptID     *int
	IDs          []int
	IDLt         *int
	AuthorILike  *string
}

func (rs *ReviewSearch) Apply(query *orm.Query) *orm.Query {
	if rs == nil {
		return query
	}
	if rs.ID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.ID, rs.ID)
	}
	if rs.ProjectID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.ProjectID, rs.ProjectID)
	}
	if rs.Title != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Title, rs.Title)
	}
	if rs.Description != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Description, rs.Description)
	}
	if rs.ExternalID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.ExternalID, rs.ExternalID)
	}
	if rs.TrafficLight != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.TrafficLight, rs.TrafficLight)
	}
	if rs.CommitHash != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.CommitHash, rs.CommitHash)
	}
	if rs.SourceBranch != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.SourceBranch, rs.SourceBranch)
	}
	if rs.TargetBranch != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.TargetBranch, rs.TargetBranch)
	}
	if rs.Author != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.Author, rs.Author)
	}
	if rs.CreatedAt != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.CreatedAt, rs.CreatedAt)
	}
	if rs.DurationMS != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.DurationMS, rs.DurationMS)
	}
	if rs.StatusID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.StatusID, rs.StatusID)
	}
	if rs.PromptID != nil {
		rs.where(query, Tables.Review.Alias, Columns.Review.PromptID, rs.PromptID)
	}
	if len(rs.IDs) > 0 {
		Filter{Columns.Review.ID, rs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if rs.IDLt != nil {
		Filter{Columns.Review.ID, *rs.IDLt, SearchTypeLess, false}.Apply(query)
	}
	if rs.AuthorILike != nil {
		Filter{Columns.Review.Author, *rs.AuthorILike, SearchTypeILike, false}.Apply(query)
	}

	rs.apply(query)

	return query
}

func (rs *ReviewSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if rs == nil {
			return query, nil
		}
		return rs.Apply(query), nil
	}
}

type ProjectSearch struct {
	search

	ID              *int
	Title           *string
	VcsURL          *string
	Language        *string
	ProjectKey      *string
	PromptID        *int
	TaskTrackerID   *int
	SlackChannelID  *int
	CreatedAt       *time.Time
	StatusID        *int
	Instructions    *string
	IDs             []int
	TitleILike      *string
	VcsURLILike     *string
	LanguageILike   *string
	ProjectKeyILike *string
}

func (ps *ProjectSearch) Apply(query *orm.Query) *orm.Query {
	if ps == nil {
		return query
	}
	if ps.ID != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.ID, ps.ID)
	}
	if ps.Title != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.Title, ps.Title)
	}
	if ps.VcsURL != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.VcsURL, ps.VcsURL)
	}
	if ps.Language != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.Language, ps.Language)
	}
	if ps.ProjectKey != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.ProjectKey, ps.ProjectKey)
	}
	if ps.PromptID != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.PromptID, ps.PromptID)
	}
	if ps.TaskTrackerID != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.TaskTrackerID, ps.TaskTrackerID)
	}
	if ps.SlackChannelID != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.SlackChannelID, ps.SlackChannelID)
	}
	if ps.CreatedAt != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.CreatedAt, ps.CreatedAt)
	}
	if ps.StatusID != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.StatusID, ps.StatusID)
	}
	if ps.Instructions != nil {
		ps.where(query, Tables.Project.Alias, Columns.Project.Instructions, ps.Instructions)
	}
	if len(ps.IDs) > 0 {
		Filter{Columns.Project.ID, ps.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ps.TitleILike != nil {
		Filter{Columns.Project.Title, *ps.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.VcsURLILike != nil {
		Filter{Columns.Project.VcsURL, *ps.VcsURLILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.LanguageILike != nil {
		Filter{Columns.Project.Language, *ps.LanguageILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.ProjectKeyILike != nil {
		Filter{Columns.Project.ProjectKey, *ps.ProjectKeyILike, SearchTypeILike, false}.Apply(query)
	}

	ps.apply(query)

	return query
}

func (ps *ProjectSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ps == nil {
			return query, nil
		}
		return ps.Apply(query), nil
	}
}

type PromptSearch struct {
	search

	ID                *int
	Title             *string
	Common            *string
	Architecture      *string
	Code              *string
	Security          *string
	Tests             *string
	CreatedAt         *time.Time
	StatusID          *int
	IDs               []int
	TitleILike        *string
	CommonILike       *string
	ArchitectureILike *string
	CodeILike         *string
	SecurityILike     *string
	TestsILike        *string
}

func (ps *PromptSearch) Apply(query *orm.Query) *orm.Query {
	if ps == nil {
		return query
	}
	if ps.ID != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.ID, ps.ID)
	}
	if ps.Title != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.Title, ps.Title)
	}
	if ps.Common != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.Common, ps.Common)
	}
	if ps.Architecture != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.Architecture, ps.Architecture)
	}
	if ps.Code != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.Code, ps.Code)
	}
	if ps.Security != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.Security, ps.Security)
	}
	if ps.Tests != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.Tests, ps.Tests)
	}
	if ps.CreatedAt != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.CreatedAt, ps.CreatedAt)
	}
	if ps.StatusID != nil {
		ps.where(query, Tables.Prompt.Alias, Columns.Prompt.StatusID, ps.StatusID)
	}
	if len(ps.IDs) > 0 {
		Filter{Columns.Prompt.ID, ps.IDs, SearchTypeArray, false}.Apply(query)
	}
	if ps.TitleILike != nil {
		Filter{Columns.Prompt.Title, *ps.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.CommonILike != nil {
		Filter{Columns.Prompt.Common, *ps.CommonILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.ArchitectureILike != nil {
		Filter{Columns.Prompt.Architecture, *ps.ArchitectureILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.CodeILike != nil {
		Filter{Columns.Prompt.Code, *ps.CodeILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.SecurityILike != nil {
		Filter{Columns.Prompt.Security, *ps.SecurityILike, SearchTypeILike, false}.Apply(query)
	}
	if ps.TestsILike != nil {
		Filter{Columns.Prompt.Tests, *ps.TestsILike, SearchTypeILike, false}.Apply(query)
	}

	ps.apply(query)

	return query
}

func (ps *PromptSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if ps == nil {
			return query, nil
		}
		return ps.Apply(query), nil
	}
}

type SlackChannelSearch struct {
	search

	ID              *int
	Title           *string
	Channel         *string
	WebhookURL      *string
	StatusID        *int
	IDs             []int
	TitleILike      *string
	ChannelILike    *string
	WebhookURLILike *string
}

func (scs *SlackChannelSearch) Apply(query *orm.Query) *orm.Query {
	if scs == nil {
		return query
	}
	if scs.ID != nil {
		scs.where(query, Tables.SlackChannel.Alias, Columns.SlackChannel.ID, scs.ID)
	}
	if scs.Title != nil {
		scs.where(query, Tables.SlackChannel.Alias, Columns.SlackChannel.Title, scs.Title)
	}
	if scs.Channel != nil {
		scs.where(query, Tables.SlackChannel.Alias, Columns.SlackChannel.Channel, scs.Channel)
	}
	if scs.WebhookURL != nil {
		scs.where(query, Tables.SlackChannel.Alias, Columns.SlackChannel.WebhookURL, scs.WebhookURL)
	}
	if scs.StatusID != nil {
		scs.where(query, Tables.SlackChannel.Alias, Columns.SlackChannel.StatusID, scs.StatusID)
	}
	if len(scs.IDs) > 0 {
		Filter{Columns.SlackChannel.ID, scs.IDs, SearchTypeArray, false}.Apply(query)
	}
	if scs.TitleILike != nil {
		Filter{Columns.SlackChannel.Title, *scs.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if scs.ChannelILike != nil {
		Filter{Columns.SlackChannel.Channel, *scs.ChannelILike, SearchTypeILike, false}.Apply(query)
	}
	if scs.WebhookURLILike != nil {
		Filter{Columns.SlackChannel.WebhookURL, *scs.WebhookURLILike, SearchTypeILike, false}.Apply(query)
	}

	scs.apply(query)

	return query
}

func (scs *SlackChannelSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if scs == nil {
			return query, nil
		}
		return scs.Apply(query), nil
	}
}

type TaskTrackerSearch struct {
	search

	ID               *int
	Title            *string
	AuthToken        *string
	FetchPrompt      *string
	CreatedAt        *time.Time
	StatusID         *int
	URL              *string
	IDs              []int
	TitleILike       *string
	AuthTokenILike   *string
	FetchPromptILike *string
}

func (tts *TaskTrackerSearch) Apply(query *orm.Query) *orm.Query {
	if tts == nil {
		return query
	}
	if tts.ID != nil {
		tts.where(query, Tables.TaskTracker.Alias, Columns.TaskTracker.ID, tts.ID)
	}
	if tts.Title != nil {
		tts.where(query, Tables.TaskTracker.Alias, Columns.TaskTracker.Title, tts.Title)
	}
	if tts.AuthToken != nil {
		tts.where(query, Tables.TaskTracker.Alias, Columns.TaskTracker.AuthToken, tts.AuthToken)
	}
	if tts.FetchPrompt != nil {
		tts.where(query, Tables.TaskTracker.Alias, Columns.TaskTracker.FetchPrompt, tts.FetchPrompt)
	}
	if tts.CreatedAt != nil {
		tts.where(query, Tables.TaskTracker.Alias, Columns.TaskTracker.CreatedAt, tts.CreatedAt)
	}
	if tts.StatusID != nil {
		tts.where(query, Tables.TaskTracker.Alias, Columns.TaskTracker.StatusID, tts.StatusID)
	}
	if tts.URL != nil {
		tts.where(query, Tables.TaskTracker.Alias, Columns.TaskTracker.URL, tts.URL)
	}
	if len(tts.IDs) > 0 {
		Filter{Columns.TaskTracker.ID, tts.IDs, SearchTypeArray, false}.Apply(query)
	}
	if tts.TitleILike != nil {
		Filter{Columns.TaskTracker.Title, *tts.TitleILike, SearchTypeILike, false}.Apply(query)
	}
	if tts.AuthTokenILike != nil {
		Filter{Columns.TaskTracker.AuthToken, *tts.AuthTokenILike, SearchTypeILike, false}.Apply(query)
	}
	if tts.FetchPromptILike != nil {
		Filter{Columns.TaskTracker.FetchPrompt, *tts.FetchPromptILike, SearchTypeILike, false}.Apply(query)
	}

	tts.apply(query)

	return query
}

func (tts *TaskTrackerSearch) Q() applier {
	return func(query *orm.Query) (*orm.Query, error) {
		if tts == nil {
			return query, nil
		}
		return tts.Apply(query), nil
	}
}
